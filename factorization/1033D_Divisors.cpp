#include<bits/stdc++.h>		// эта бибилиотека включает в себя
				// множество других полезных библиотек
using namespace std;

int n;				// количество перемножаемых чисел a_i
long long a[500];		// массив перемножаемых числел a_i
long long res = 1;		// количество делителей числа a = ∏(a_i)
long long p;			// простой множитель в канонической форме a_i
int mod = 998244353;		// модуль

/*------------------О контейнере fact------------------
Ключ: 
	либо простой множитель из канонической формы a_i,

	либо сам a_i
-------------------------------------------------------
Значение:
	либо сумма показателей степеней одинаковых простых
	множителей в канонической форме различных a_i,

	либо (P + 1) * (Q + 1) - 1
	где P и Q - количество протсых чисел p и q
	в канонических формах вида pq различных a_i
-----------------------------------------------------*/
map<long long, int> fact;

int main() {
    // для ускорения cin и cout отключаем
    // синхронизацию всех потоков iostream
    // c стандартными потоками C (stdio, stdout, stderr)
    ios_base::sync_with_stdio(0);

    // отключаем привязку cin к cout,
    // т.е. оключаем сброс буфера cout,
    // перед использованием cin
    cin.tie(0);

    cin >> n;	// ввод количество перемножаемых чисел a_i
    for (int i = 0; i < n; i++)
        cin >> a[i];	// ввод перемножаемых чисел a_i

    /*--------------------Немного об алгоритме решения---------------------
    	Находить количество делителей числа a
    	будем по формуле: ∏(r_i + 1),
    	где r_i степень множителя в канонической записи a,
    	т.е. записи вида: a = p_1^r_1 * p_2^r_2 * ... p_m^r_m
	  ---------------------------------------------------------------------
    	По условию задачи гарантируется,
    	что количество делителей каждого a_i от 3 до 5.

    	Следовательно возможны 4 формы канонической записи a_i:
    	p^2, p^3, p^4, pq, где p и q - простые числа

    	В таком случае достаточно определить к какому виду относится
    	текущий a_i и добавить соответсвующий показатель степени
    	в контейнер к соответсвующему числу
	  ---------------------------------------------------------------------
    	Проблематична форма pq.

    	Если найдется a_j ≠ a_i и НОД(a_i, a_j) ≠ 1,
    	то мы можем разложить a_i на p = НОД и q = a_i / НОД.

    	Если a_j ≠ a_i, но НОД(a_i, a_j) ≠ 1, то поступим иным образом.
    	Мы знаем, что выражение (P + 1) * (Q + 1),
    	где P и Q - количество протсых чисел p и q в a_i
    	(обратите внимание P = Q), всегда равняется 4.
	
    	Для того, чтобы все верно подсчитать
	по формуле ∏(r_i + 1) можно вместо p_i добавлять
	в контейнер в роле ключа a_i, а его значением будет
	(P + 1) * (Q + 1) - 1 = (P + 1)^2, т.е. 3.
     ---------------------------------------------------------------------
	Хорошо. А если найдется a_j = a_i?
	В таком случае можно преобразовать предыдущие рассуждения.
	При нахождение a_j = a_i, будем изменять предыдущее (P + 1)^2 - 1.
	Об этом подробно распсанно в отчете
      ---------------------------------------------------------------------*/
    
    for (int i = 0; i < n; i++) {
        p = sqrt(a[i]);		// sqrt - функция библиотеки <math.h>
        if (p*p == a[i]) { 	// проверяем вид p^2 и p^4
            long long tmp = sqrt(p); 
            if(tmp*tmp*tmp*tmp == a[i])	// проверяем вид p^4
                fact[tmp] += 4;
            else
                fact[p] += 2;
        }
        else {
            p = cbrtl(a[i]);	// cbrtl - функция библиотеки <math.h>
            if (p*p*p == a[i]) 	// проверяем вид p^3
                fact[p] += 3;
            else {
            	// проверяем возможность разложения при помощи НОД
                bool flag = false;
                for (int j = 0; j < n && !flag; j++) {
                    if ( a[i] != a[j]) {
                    	// __gcd - функция библиотеки <algoritm>,
                    	// можно написать собственную
                        long long g = __gcd(a[i], a[j]);
                        if (g != 1) {
                            fact[g] ++;
                            fact[a[i]/g] ++;
                            flag = true;
                        }
                    }
                }
                // в крайнем случае изменяем значение по ключу а[i] 
                if (!flag) {
                    fact[a[i]] = sqrt(fact[a[i]] + 1) + 1;
                    fact[a[i]] = fact[a[i]] * fact[a[i]] - 1;
                }
            }
        }
    }

    // нахождение ∏(r_i + 1)
    for (auto i : fact)
        res = res * (i.second + 1) % mod;

    cout << res << endl;

    return 0;
}
